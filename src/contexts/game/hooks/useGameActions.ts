
import { useState } from 'react';
import { Game, Player, DailyDraw } from '../types';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/components/ui/use-toast';

/**
 * Custom hook for game CRUD operations
 */
export const useGameActions = (games: Game[], setGames: React.Dispatch<React.SetStateAction<Game[]>>) => {
  const { toast } = useToast();
  const [isLoading, setIsLoading] = useState(true);

  /**
   * Add a new game to the database and state
   */
  const addGame = async (game: Omit<Game, 'id'>): Promise<Game> => {
    try {
      if (!game) throw new Error('Game data is required');
      
      // Log what we're sending to Supabase for debugging
      console.log('Adding game with data:', {
        name: game.name,
        start_date: game.startDate,
        end_date: game.endDate,
        status: game.status,
        owner_id: game.owner_id
      });
      
      // Insert the game into Supabase
      const { data, error } = await supabase
        .from('games')
        .insert({
          name: game.name,
          start_date: game.startDate,
          end_date: game.endDate,
          status: game.status,
          owner_id: game.owner_id,
          user_id: game.owner_id // For compatibility
        })
        .select()
        .single();

      if (error) {
        console.error('Supabase error:', error);
        throw error;
      }
      
      if (!data) {
        console.error('No data returned from insert');
        throw new Error('Error creating game');
      }

      console.log('Game created successfully:', data);

      // Create new game with ID generated by Supabase
      const newGame: Game = {
        id: data.id,
        name: game.name,
        startDate: game.startDate,
        endDate: game.endDate,
        status: game.status,
        players: [],
        dailyDraws: [],
        winners: [],
        owner_id: game.owner_id
      };
      
      // Add to local list
      setGames(prev => [newGame, ...prev]);
      
      return newGame;
    } catch (error) {
      console.error('Error adding game:', error);
      toast({
        title: "Erro ao criar jogo",
        description: error instanceof Error ? error.message : "Ocorreu um erro inesperado",
        variant: "destructive"
      });
      throw error;
    }
  };

  /**
   * Update an existing game
   */
  const updateGame = async (id: string, gameUpdates: Partial<Game>): Promise<void> => {
    try {
      // Update the game in Supabase
      const { error } = await supabase
        .from('games')
        .update({
          name: gameUpdates.name,
          start_date: gameUpdates.startDate,
          end_date: gameUpdates.endDate,
          status: gameUpdates.status
        })
        .eq('id', id);

      if (error) throw error;
      
      // Update the local list
      setGames(games.map(game => 
        game.id === id ? { ...game, ...gameUpdates } : game
      ));
    } catch (error) {
      console.error('Error updating game:', error);
      toast({
        title: "Error updating game",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    }
  };

  /**
   * Delete a game from the database and state
   */
  const deleteGame = async (gameId: string): Promise<boolean> => {
    try {
      // Delete the game from Supabase (related tables will be deleted in cascade)
      const { error } = await supabase
        .from('games')
        .delete()
        .eq('id', gameId);

      if (error) throw error;
      
      // Update the local list
      setGames(games.filter(game => game.id !== gameId));
      
      return true;
    } catch (error) {
      console.error('Error deleting game:', error);
      toast({
        title: "Error deleting game",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
      return false;
    }
  };

  /**
   * Load games from Supabase
   */
  const loadGamesFromSupabase = async () => {
    setIsLoading(true);
    try {
      // Fetch all games for the user
      const { data: gamesData, error: gamesError } = await supabase
        .from('games')
        .select('*')
        .order('created_at', { ascending: false });

      if (gamesError) {
        throw gamesError;
      }

      if (!gamesData) {
        setGames([]);
        setIsLoading(false);
        return;
      }

      // For each game, fetch players, daily draws and winners
      const fullGames = await Promise.all(
        gamesData.map(async (game) => {
          // Fetch players
          const { data: playersData } = await supabase
            .from('players')
            .select('*')
            .eq('game_id', game.id);

          // For each player, fetch their combinations
          const players = await Promise.all(
            (playersData || []).map(async (player) => {
              const { data: combinationsData } = await supabase
                .from('player_combinations')
                .select('*')
                .eq('player_id', player.id);

              return {
                id: player.id,
                name: player.name,
                combinations: (combinationsData || []).map(combo => ({
                  numbers: combo.numbers,
                  hits: combo.hits || 0
                }))
              } as Player;
            })
          );

          // Fetch daily draws
          const { data: dailyDrawsData } = await supabase
            .from('daily_draws')
            .select('*')
            .eq('game_id', game.id)
            .order('date', { ascending: true });

          const dailyDraws = (dailyDrawsData || []).map(draw => ({
            id: draw.id,
            date: draw.date,
            numbers: draw.numbers
          })) as DailyDraw[];

          // Fetch winners
          const { data: winnersData } = await supabase
            .from('winners')
            .select('player_id, combination_id')
            .eq('game_id', game.id);

          // Map winners to corresponding players
          let winners: Player[] = [];
          if (winnersData && winnersData.length > 0) {
            // Create a set of unique winner player IDs
            const winnerPlayerIds = [...new Set(winnersData.map(w => w.player_id))];
            
            // Filter winning players from the players list
            winners = players.filter(player => 
              winnerPlayerIds.includes(player.id)
            );
          }

          // Ensure the status is always 'active' or 'closed'
          let gameStatus = game.status === 'active' ? 'active' : 'closed';
          
          return {
            id: game.id,
            name: game.name,
            startDate: game.start_date,
            endDate: game.end_date,
            status: gameStatus,
            players,
            dailyDraws,
            winners,
            owner_id: game.owner_id
          } as Game;
        })
      );

      setGames(fullGames.map(game => recalculatePlayerHits(game)));
    } catch (error) {
      console.error('Error loading games:', error);
      toast({
        title: "Error loading games",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Recalculate hits for all player combinations based on all drawn numbers
  const recalculatePlayerHits = (game: Game): Game => {
    if (!game.dailyDraws || game.dailyDraws.length === 0) return game;
    
    const allDrawnNumbers = game.dailyDraws.flatMap(draw => draw.numbers);
    
    const updatedPlayers = game.players.map(player => {
      const updatedCombinations = player.combinations.map(combo => {
        const hits = combo.numbers.filter(num => allDrawnNumbers.includes(num)).length;
        return { ...combo, hits };
      });
      
      return {
        ...player,
        combinations: updatedCombinations
      };
    });
    
    return {
      ...game,
      players: updatedPlayers
    };
  };

  return { 
    addGame, 
    updateGame, 
    deleteGame, 
    loadGamesFromSupabase,
    recalculatePlayerHits,
    isLoading 
  };
};
